{"version":3,"sources":["../../src/differentialDownloader/DifferentialDownloader.ts"],"names":[],"mappings":"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","sourcesContent":["import BluebirdPromise from \"bluebird-lst\"\r\nimport { BlockMapDataHolder, configureRequestOptionsFromUrl, createHttpError, DigestTransform, HttpExecutor } from \"builder-util-runtime\"\r\nimport { BlockMap } from \"builder-util-runtime/out/blockMapApi\"\r\nimport { close, createWriteStream, open } from \"fs-extra-p\"\r\nimport { OutgoingHttpHeaders, RequestOptions } from \"http\"\r\nimport { Logger } from \"../main\"\r\nimport { copyData } from \"./DataSplitter\"\r\nimport { computeOperations, Operation, OperationKind } from \"./downloadPlanBuilder\"\r\nimport { checkIsRangesSupported, executeTasks } from \"./multipleRangeDownloader\"\r\n\r\nconst inflateRaw: any = BluebirdPromise.promisify(require(\"zlib\").inflateRaw)\r\n\r\nexport interface DifferentialDownloaderOptions {\r\n  readonly oldFile: string\r\n  readonly newUrl: string\r\n  readonly logger: Logger\r\n  readonly newFile: string\r\n\r\n  readonly requestHeaders: OutgoingHttpHeaders | null\r\n\r\n  readonly useMultipleRangeRequest?: boolean\r\n}\r\n\r\nexport abstract class DifferentialDownloader {\r\n  private readonly baseRequestOptions: RequestOptions\r\n\r\n  fileMetadataBuffer: Buffer | null = null\r\n\r\n  private readonly logger: Logger\r\n\r\n  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\r\n  constructor(protected readonly blockAwareFileInfo: BlockMapDataHolder, readonly httpExecutor: HttpExecutor<any>, readonly options: DifferentialDownloaderOptions) {\r\n    this.logger = options.logger\r\n    this.baseRequestOptions = configureRequestOptionsFromUrl(options.newUrl, {})\r\n  }\r\n\r\n  createRequestOptions(method: \"head\" | \"get\" = \"get\", newUrl?: string | null): RequestOptions {\r\n    return {\r\n      ...(newUrl == null ? this.baseRequestOptions : configureRequestOptionsFromUrl(newUrl, {})),\r\n      method,\r\n      headers: {\r\n        ...this.options.requestHeaders,\r\n        accept: \"*/*\",\r\n      } as any,\r\n    }\r\n  }\r\n\r\n  protected doDownload(oldBlockMap: BlockMap, newBlockMap: BlockMap): Promise<any> {\r\n    // we don't check other metadata like compressionMethod - generic check that it is make sense to differentially update is suitable for it\r\n    if (oldBlockMap.version !== newBlockMap.version) {\r\n      throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`)\r\n    }\r\n\r\n    const logger = this.logger\r\n    const operations = computeOperations(oldBlockMap, newBlockMap, logger)\r\n    if (logger.debug != null) {\r\n      logger.debug(JSON.stringify(operations, null, 2))\r\n    }\r\n\r\n    let downloadSize = 0\r\n    let copySize = 0\r\n    for (const operation of operations) {\r\n      const length = operation.end - operation.start\r\n      if (operation.kind === OperationKind.DOWNLOAD) {\r\n        downloadSize += length\r\n      }\r\n      else {\r\n        copySize += length\r\n      }\r\n    }\r\n\r\n    const newPackageSize = this.blockAwareFileInfo.size\r\n    if ((downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length)) !== newPackageSize) {\r\n      throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newPackageSize: ${newPackageSize}`)\r\n    }\r\n\r\n    logger.info(`Full: ${formatBytes(newPackageSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newPackageSize / 100))}%)`)\r\n\r\n    return this.downloadFile(operations)\r\n  }\r\n\r\n  private downloadFile(tasks: Array<Operation>): Promise<any> {\r\n    const fdList: Array<OpenedFile> = []\r\n    const closeFiles = () => {\r\n      return BluebirdPromise.map(fdList, openedFile => {\r\n        return close(openedFile.descriptor)\r\n          .catch(e => {\r\n            this.logger.error(`cannot close file \"${openedFile.path}\": ${e}`)\r\n          })\r\n      })\r\n    }\r\n    return this.doDownloadFile(tasks, fdList)\r\n      .then(closeFiles)\r\n      .catch(e => {\r\n        // then must be after catch here (since then always throws error)\r\n        return closeFiles()\r\n          .catch(closeFilesError => {\r\n            // closeFiles never throw error, but just to be sure\r\n            try {\r\n              this.logger.error(`cannot close files: ${closeFilesError}`)\r\n            }\r\n            catch (errorOnLog) {\r\n              try {\r\n                console.error(errorOnLog)\r\n              }\r\n              catch (ignored) {\r\n                // ok, give up and ignore error\r\n              }\r\n            }\r\n            throw e\r\n          })\r\n          .then(() => {\r\n            throw e\r\n          })\r\n      })\r\n  }\r\n\r\n  private async doDownloadFile(tasks: Array<Operation>, fdList: Array<OpenedFile>): Promise<any> {\r\n    const oldFileFd = await open(this.options.oldFile, \"r\")\r\n    fdList.push({descriptor: oldFileFd, path: this.options.oldFile})\r\n    const newFileFd = await open(this.options.newFile, \"w\")\r\n    fdList.push({descriptor: newFileFd, path: this.options.newFile})\r\n    const fileOut = createWriteStream(this.options.newFile, {fd: newFileFd})\r\n    await new Promise((resolve, reject) => {\r\n      const streams: Array<any> = []\r\n      const digestTransform = new DigestTransform(this.blockAwareFileInfo.sha512)\r\n      // to simply debug, do manual validation to allow file to be fully written\r\n      digestTransform.isValidateOnEnd = false\r\n      streams.push(digestTransform)\r\n\r\n      // noinspection JSArrowFunctionCanBeReplacedWithShorthand\r\n      fileOut.on(\"finish\", () => {\r\n        (fileOut.close as any)(() => {\r\n          try {\r\n            digestTransform.validate()\r\n          }\r\n          catch (e) {\r\n            reject(e)\r\n            return\r\n          }\r\n\r\n          resolve()\r\n        })\r\n      })\r\n\r\n      streams.push(fileOut)\r\n\r\n      let lastStream = null\r\n      for (const stream of streams) {\r\n        stream.on(\"error\", reject)\r\n        if (lastStream == null) {\r\n          lastStream = stream\r\n        }\r\n        else {\r\n          lastStream = lastStream.pipe(stream)\r\n        }\r\n      }\r\n\r\n      const firstStream = streams[0]\r\n\r\n      let w: any\r\n      if (this.options.useMultipleRangeRequest) {\r\n        w = executeTasks(this, tasks, firstStream, oldFileFd, reject)\r\n      }\r\n      else {\r\n        let attemptCount = 0\r\n        let actualUrl: string | null = null\r\n        this.logger.info(`Differential download: ${this.options.newUrl}`)\r\n        w = (index: number) => {\r\n          if (index >= tasks.length) {\r\n            if (this.fileMetadataBuffer != null) {\r\n              firstStream.write(this.fileMetadataBuffer)\r\n            }\r\n            firstStream.end()\r\n            return\r\n          }\r\n\r\n          const operation = tasks[index++]\r\n          if (operation.kind === OperationKind.COPY) {\r\n            copyData(operation, firstStream, oldFileFd, reject, () => w(index))\r\n          }\r\n          else {\r\n            const requestOptions = this.createRequestOptions(\"get\", actualUrl)\r\n            const range = `bytes=${operation.start}-${operation.end - 1}`\r\n            requestOptions.headers!!.Range = range;\r\n            (requestOptions as any).redirect = \"manual\"\r\n\r\n            const debug = this.logger.debug\r\n            if (debug != null) {\r\n              debug(`effective url: ${actualUrl == null ? \"original\" : removeQuery(actualUrl)}, range: ${range}`)\r\n            }\r\n\r\n            const request = this.httpExecutor.doRequest(requestOptions, response => {\r\n              // Electron net handles redirects automatically, our NodeJS test server doesn't use redirects - so, we don't check 3xx codes.\r\n              if (response.statusCode >= 400) {\r\n                reject(createHttpError(response))\r\n              }\r\n\r\n              response.pipe(firstStream, {\r\n                end: false\r\n              })\r\n              response.once(\"end\", () => {\r\n                if (++attemptCount === 100) {\r\n                  attemptCount = 0\r\n                  setTimeout(() => w(index), 1000)\r\n                }\r\n                else {\r\n                  w(index)\r\n                }\r\n              })\r\n            })\r\n            request.on(\"redirect\", (statusCode: number, method: string, redirectUrl: string) => {\r\n              this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`)\r\n              actualUrl = redirectUrl\r\n              request.followRedirect()\r\n            })\r\n            this.httpExecutor.addErrorAndTimeoutHandlers(request, reject)\r\n            request.end()\r\n          }\r\n        }\r\n      }\r\n\r\n      w(0)\r\n    })\r\n  }\r\n\r\n  protected async readRemoteBytes(start: number, endInclusive: number) {\r\n    const buffer = Buffer.allocUnsafe((endInclusive + 1) - start)\r\n    const requestOptions = this.createRequestOptions()\r\n    requestOptions.headers!!.Range = `bytes=${start}-${endInclusive}`\r\n    let position = 0\r\n    await this.request(requestOptions, chunk => {\r\n      chunk.copy(buffer, position)\r\n      position += chunk.length\r\n    })\r\n    return buffer\r\n  }\r\n\r\n  private request(requestOptions: RequestOptions, dataHandler: (chunk: Buffer) => void) {\r\n    return new Promise((resolve, reject) => {\r\n      const request = this.httpExecutor.doRequest(requestOptions, response => {\r\n        if (!checkIsRangesSupported(response, reject)) {\r\n          return\r\n        }\r\n\r\n        response.on(\"data\", dataHandler)\r\n        response.on(\"end\", () => resolve())\r\n      })\r\n      this.httpExecutor.addErrorAndTimeoutHandlers(request, reject)\r\n      request.end()\r\n    })\r\n  }\r\n}\r\n\r\nexport async function readBlockMap(data: Buffer): Promise<BlockMap> {\r\n  return JSON.parse((await inflateRaw(data)).toString())\r\n}\r\n\r\nfunction formatBytes(value: number, symbol = \" KB\") {\r\n  return new Intl.NumberFormat(\"en\").format((value / 1024).toFixed(2) as any) + symbol\r\n}\r\n\r\n// safety\r\nfunction removeQuery(url: string) {\r\n  const index = url.indexOf(\"?\")\r\n  return index < 0 ? url : url.substring(0, index)\r\n}\r\n\r\ninterface OpenedFile {\r\n  readonly descriptor: number\r\n  readonly path: string\r\n}"],"sourceRoot":""}
