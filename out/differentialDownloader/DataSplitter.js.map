{"version":3,"file":"DataSplitter.js","sourceRoot":"","sources":["../../src/differentialDownloader/DataSplitter.ts"],"names":[],"mappings":"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","sourcesContent":["import { newError } from \"builder-util-runtime\"\r\nimport { createReadStream } from \"fs-extra-p\"\r\nimport { Writable } from \"stream\"\r\nimport { Operation, OperationKind } from \"./downloadPlanBuilder\"\r\n\r\nconst DOUBLE_CRLF = Buffer.from(\"\\r\\n\\r\\n\")\r\n\r\nenum ReadState {\r\n  INIT, HEADER, BODY\r\n}\r\n\r\nexport interface PartListDataTask {\r\n  readonly oldFileFd: number\r\n  readonly tasks: Array<Operation>\r\n  readonly start: number\r\n  readonly end: number\r\n}\r\n\r\nexport function copyData(task: Operation, out: Writable, oldFileFd: number, reject: (error: Error) => void, resolve: () => void) {\r\n  const readStream = createReadStream(\"\", {\r\n    fd: oldFileFd,\r\n    autoClose: false,\r\n    start: task.start,\r\n    // end is inclusive\r\n    end: task.end - 1,\r\n  })\r\n  readStream.on(\"error\", reject)\r\n  readStream.once(\"end\", resolve)\r\n  readStream.pipe(out, {\r\n    end: false\r\n  })\r\n}\r\n\r\nexport class DataSplitter extends Writable {\r\n  partIndex = -1\r\n\r\n  private headerListBuffer: Buffer | null = null\r\n  private readState = ReadState.INIT\r\n  private ignoreByteCount = 0\r\n  private remainingPartDataCount = 0\r\n\r\n  private readonly boundaryLength: number\r\n\r\n  constructor(private readonly out: Writable, private readonly options: PartListDataTask, private readonly partIndexToTaskIndex: Map<number, number>, boundary: string, private readonly partIndexToLength: Array<number>, private readonly finishHandler: () => any) {\r\n    super()\r\n\r\n    this.boundaryLength = boundary.length + 4 /* size of \\r\\n-- */\r\n    // first chunk doesn't start with \\r\\n\r\n    this.ignoreByteCount = this.boundaryLength - 2\r\n  }\r\n\r\n  get isFinished() {\r\n    return this.partIndex === this.partIndexToLength.length\r\n  }\r\n\r\n  // noinspection JSUnusedGlobalSymbols\r\n  _write(data: Buffer, encoding: string, callback: (error?: Error) => void) {\r\n    if (this.isFinished) {\r\n      console.error(`Trailing ignored data: ${data.length} bytes`)\r\n      return\r\n    }\r\n\r\n    this.handleData(data)\r\n      .then(callback)\r\n      .catch(callback)\r\n  }\r\n\r\n  private async handleData(chunk: Buffer): Promise<undefined> {\r\n    let start = 0\r\n\r\n    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0) {\r\n      throw newError(\"Internal error\", \"ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH\")\r\n    }\r\n\r\n    if (this.ignoreByteCount > 0) {\r\n      const toIgnore = Math.min(this.ignoreByteCount, chunk.length)\r\n      this.ignoreByteCount -= toIgnore\r\n      start = toIgnore\r\n    }\r\n    else if (this.remainingPartDataCount > 0) {\r\n      const toRead = Math.min(this.remainingPartDataCount, chunk.length)\r\n      this.remainingPartDataCount -= toRead\r\n      await this.processPartData(chunk, 0, toRead)\r\n      start = toRead\r\n    }\r\n\r\n    if (start === chunk.length) {\r\n      return\r\n    }\r\n\r\n    if (this.readState === ReadState.HEADER) {\r\n      const headerListEnd = this.searchHeaderListEnd(chunk, start)\r\n      if (headerListEnd === -1) {\r\n        return\r\n      }\r\n\r\n      start = headerListEnd\r\n      this.readState = ReadState.BODY\r\n      // header list is ignored, we don't need it\r\n      this.headerListBuffer = null\r\n    }\r\n\r\n    while (true) {\r\n      if (this.readState === ReadState.BODY) {\r\n        this.readState = ReadState.INIT\r\n      }\r\n      else {\r\n        this.partIndex++\r\n\r\n        let taskIndex = this.partIndexToTaskIndex.get(this.partIndex)\r\n        if (taskIndex == null) {\r\n          if (this.isFinished) {\r\n            taskIndex = this.options.end\r\n          }\r\n          else {\r\n            throw newError(\"taskIndex is null\", \"ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL\")\r\n          }\r\n        }\r\n\r\n        const prevTaskIndex = this.partIndex === 0 ? this.options.start : (this.partIndexToTaskIndex.get(this.partIndex - 1)!! + 1 /* prev part is download, next maybe copy */)\r\n        if (prevTaskIndex < taskIndex) {\r\n          await this.copyExistingData(prevTaskIndex, taskIndex)\r\n        }\r\n        else if (prevTaskIndex > taskIndex) {\r\n          throw newError(\"prevTaskIndex must be < taskIndex\", \"ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED\")\r\n        }\r\n\r\n        if (this.isFinished) {\r\n          this.onPartEnd()\r\n          this.finishHandler()\r\n          return\r\n        }\r\n\r\n        start = this.searchHeaderListEnd(chunk, start)\r\n\r\n        if (start === -1) {\r\n          this.readState = ReadState.HEADER\r\n          return\r\n        }\r\n      }\r\n\r\n      const partLength = this.partIndexToLength[this.partIndex]\r\n      const end = start + partLength\r\n      const effectiveEnd = Math.min(end, chunk.length)\r\n      await this.processPartStarted(chunk, start, effectiveEnd)\r\n      this.remainingPartDataCount = partLength - (effectiveEnd - start)\r\n      if (this.remainingPartDataCount > 0) {\r\n        return\r\n      }\r\n\r\n      start = end + this.boundaryLength\r\n      if (start >= chunk.length) {\r\n        this.ignoreByteCount = this.boundaryLength - (chunk.length - end)\r\n        return\r\n      }\r\n    }\r\n  }\r\n\r\n  private copyExistingData(index: number, end: number) {\r\n    return new Promise((resolve, reject) => {\r\n      const w = () => {\r\n        if (index === end) {\r\n          resolve()\r\n          return\r\n        }\r\n\r\n        const task = this.options.tasks[index]\r\n        if (task.kind !== OperationKind.COPY) {\r\n          reject(new Error(\"Task kind must be COPY\"))\r\n          return\r\n        }\r\n\r\n        copyData(task, this.out, this.options.oldFileFd, reject, () => {\r\n          index++\r\n          w()\r\n        })\r\n      }\r\n      w()\r\n    })\r\n  }\r\n\r\n  private searchHeaderListEnd(chunk: Buffer, readOffset: number): number {\r\n    const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset)\r\n    if (headerListEnd !== -1) {\r\n      return headerListEnd + DOUBLE_CRLF.length\r\n    }\r\n\r\n    // not all headers data were received, save to buffer\r\n    const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset)\r\n    if (this.headerListBuffer == null) {\r\n      this.headerListBuffer = partialChunk\r\n    }\r\n    else {\r\n      this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk])\r\n    }\r\n    return -1\r\n  }\r\n\r\n  private actualPartLength = 0\r\n\r\n  private onPartEnd() {\r\n    const expectedLength = this.partIndexToLength[this.partIndex - 1]\r\n    if (this.actualPartLength !== expectedLength) {\r\n      throw newError(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, \"ERR_DATA_SPLITTER_LENGTH_MISMATCH\")\r\n    }\r\n    this.actualPartLength = 0\r\n  }\r\n\r\n  private processPartStarted(data: Buffer, start: number, end: number): Promise<void> {\r\n    if (this.partIndex !== 0) {\r\n      this.onPartEnd()\r\n    }\r\n    return this.processPartData(data, start, end)\r\n  }\r\n\r\n  private processPartData(data: Buffer, start: number, end: number): Promise<void> {\r\n    this.actualPartLength += end - start\r\n    const out = this.out\r\n    if (out.write(start === 0 && data.length === end ? data : data.slice(start, end))) {\r\n      return Promise.resolve()\r\n    }\r\n    else {\r\n      return new Promise((resolve, reject) => {\r\n        out.on(\"error\", reject)\r\n        out.once(\"drain\", () => {\r\n          out.removeListener(\"error\", reject)\r\n          resolve()\r\n        })\r\n      })\r\n    }\r\n  }\r\n}"]}