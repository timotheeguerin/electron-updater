{"version":3,"file":"AppImageUpdater.js","sourceRoot":"","sources":["../src/AppImageUpdater.ts"],"names":[],"mappings":"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","sourcesContent":["import { AllPublishOptions, newError } from \"builder-util-runtime\"\r\nimport { execFileSync, spawn } from \"child_process\"\r\nimport isDev from \"electron-is-dev\"\r\nimport { chmod, unlinkSync } from \"fs-extra-p\"\r\nimport * as path from \"path\"\r\nimport \"source-map-support/register\"\r\nimport { DownloadUpdateOptions } from \"./AppUpdater\"\r\nimport { BaseUpdater } from \"./BaseUpdater\"\r\nimport { FileWithEmbeddedBlockMapDifferentialDownloader } from \"./differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader\"\r\nimport { UpdateCheckResult } from \"./main\"\r\nimport { findFile } from \"./providers/Provider\"\r\n\r\nexport class AppImageUpdater extends BaseUpdater {\r\n  constructor(options?: AllPublishOptions | null, app?: any) {\r\n    super(options, app)\r\n  }\r\n\r\n  checkForUpdatesAndNotify(): Promise<UpdateCheckResult | null> {\r\n    if (isDev) {\r\n      return Promise.resolve(null)\r\n    }\r\n\r\n    if (process.env.APPIMAGE == null) {\r\n      if (process.env.SNAP == null) {\r\n        this._logger.warn(\"APPIMAGE env is not defined, current application is not an AppImage\")\r\n      }\r\n      else {\r\n        this._logger.info(\"SNAP env is defined, updater is disabled\")\r\n      }\r\n      return Promise.resolve(null)\r\n    }\r\n\r\n    return super.checkForUpdatesAndNotify()\r\n  }\r\n\r\n  /*** @private */\r\n  protected async doDownloadUpdate(downloadUpdateOptions: DownloadUpdateOptions): Promise<Array<string>> {\r\n    const provider = await this.provider\r\n    const fileInfo = findFile(provider.resolveFiles(downloadUpdateOptions.updateInfo), \"AppImage\")!!\r\n    return await this.executeDownload({\r\n      fileExtension: \"AppImage\",\r\n      fileInfo,\r\n      downloadUpdateOptions,\r\n      task: async (updateFile, downloadOptions) => {\r\n        const oldFile = process.env.APPIMAGE!!\r\n        if (oldFile == null) {\r\n          throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\r\n        }\r\n\r\n        let isDownloadFull = false\r\n        try {\r\n          await new FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, {\r\n            newUrl: fileInfo.url.href,\r\n            oldFile,\r\n            logger: this._logger,\r\n            newFile: updateFile,\r\n            useMultipleRangeRequest: provider.useMultipleRangeRequest,\r\n            requestHeaders: downloadUpdateOptions.requestHeaders,\r\n          })\r\n            .download()\r\n        }\r\n        catch (e) {\r\n          this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`)\r\n          // during test (developer machine mac) we must throw error\r\n          isDownloadFull = process.platform === \"linux\"\r\n        }\r\n\r\n        if (isDownloadFull) {\r\n          await this.httpExecutor.download(fileInfo.url.href, updateFile, downloadOptions)\r\n        }\r\n\r\n        await chmod(updateFile, 0o755)\r\n      },\r\n    })\r\n  }\r\n\r\n  protected async doInstall(installerPath: string, isSilent: boolean, isRunAfter: boolean): Promise<boolean> {\r\n    const appImageFile = process.env.APPIMAGE!!\r\n    if (appImageFile == null) {\r\n      throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\r\n    }\r\n\r\n    // https://stackoverflow.com/a/1712051/1910191\r\n    unlinkSync(appImageFile)\r\n\r\n    let destination: string\r\n    const existingBaseName = path.basename(appImageFile)\r\n    // https://github.com/electron-userland/electron-builder/issues/2964\r\n    // if no version in existing file name, it means that user wants to preserve current custom name\r\n    if (path.basename(installerPath) === existingBaseName || !/\\d+\\.\\d+\\.\\d+/.test(existingBaseName)) {\r\n      // no version in the file name, overwrite existing\r\n      destination = appImageFile\r\n    }\r\n    else {\r\n      destination = path.join(path.dirname(appImageFile), path.basename(installerPath))\r\n    }\r\n\r\n    execFileSync(\"mv\", [\"-f\", installerPath, destination])\r\n\r\n    const env: any = {\r\n      ...process.env,\r\n      APPIMAGE_SILENT_INSTALL: \"true\",\r\n    }\r\n\r\n    if (isRunAfter) {\r\n      spawn(destination, [], {\r\n        detached: true,\r\n        stdio: \"ignore\",\r\n        env,\r\n      })\r\n        .unref()\r\n    }\r\n    else {\r\n      env.APPIMAGE_EXIT_AFTER_INSTALL = \"true\"\r\n      execFileSync(destination, [], {env})\r\n    }\r\n    return true\r\n  }\r\n}"]}